
var _ = require('underscorem');

var filters = require('./viewfilters');

var sets = require('./viewsetclasses');


function makePathSet(contextSchema, expr, schema, objects, broadcaster, variableMap, handle){
	_.assertObject(handle);
	
	_.assertEqual(viewSchema.params.length, params.length);
	
	var s;
	var dcs;

	if(expr.type === 'property'){

		var ps;
		_.assertString(expr.name);
		if(expr.of){
			_.assertUndefined(contextSchema);
			var contextSet = makePathSet(undefined, expr.of, viewSchema, schema, objects, broadcaster, params, handle);
			var p = contextSet.getSchema().properties[expr.name];
			ps = new sets.PropertySet(p.code);
			ps.setContextSet(contextSet);
		}else{
			var p = contextSchema.properties[expr.name];
			console.log('cs: ' + JSON.stringify(contextSchema));
			console.log(expr.name);
			ps = new sets.PropertySet(p.code);
		}
		return ps;

	}else if(expr.type === 'param'){
		_.assertUndefined(contextSchema);
		//console.log(expr);
		var param = viewSchema.paramsByName[expr.name];
		if(param === undefined){
			_.errout('unknown param (TODO detect at schema compile time): ' + expr.name);
		}
		var v = params[param.index];

		_.assertDefined(v);
		return v;
	}else if(expr.type === 'value'){
		return new sets.ValueSet(expr.value);
	}else if(expr.type === 'type'){
		return handle.makeSet(expr, viewSchema, schema, objects, params, broadcaster, vs, getView);
	}else{
		_.errout('TODO: ' + JSON.stringify(expr));
	}
}


function makeRelSet(rel, schema, fullSchema, objectState, variableMap, broadcaster, getView, handle){
	_.assertLength(arguments, 8);
	_.assertObject(handle);
	
	//TODO
	this.broadcaster = broadcaster;
	//console.log('rel:');
	//console.log(rel);
	if(rel.type === 'type'){
		var objSchema = fullSchema[rel.name];
		if(objSchema === undefined){
			_.errout('rel not found(' + rel.name + ') in: ' + JSON.stringify(fullSchema));
		}
		var typeCode = objSchema.code;
		_.assertInt(typeCode);
		return new sets.ObjectsOfTypeSet(typeCode, fullSchema, objectState, broadcaster);
	}else if(rel.type === 'param'){

		//console.log(JSON.stringify(rel));
		var set = variableMap[rel.name];
		if(set === undefined){
			_.errout('cannot find param named(' + rel.name + '), only: ' + JSON.stringify(_.keys(variableMap)));
		}
		_.assertObject(set);
		return set;
	}else if(rel.type === 'view'){
		if(rel.view === 'count'){
			_.assertLength(rel.params, 1);

			var inputSet = makeRelSet(rel.params[0], schema, fullSchema, objectState, variableMap, broadcaster, getView, handle);
			return new sets.CountSet(inputSet);
		}else if(rel.view === 'filter'){
			//_.errout('TODO');
			var inputSet = makeRelSet(rel.params[0],  schema, fullSchema, objectState, variableMap, broadcaster, getView, handle);
			var filterSet = makeRelSet(rel.params[1], schema, fullSchema, objectState, variableMap, broadcaster, getView, handle);
			return new sets.FilterSet(inputSet, filterSet);
		}else if(rel.view === 'is'){
			var aSet = makeRelSet(rel.params[0],  schema, fullSchema, objectState, variableMap, broadcaster, getView, handle);
			var bSet = makeRelSet(rel.params[1], schema, fullSchema, objectState, variableMap, broadcaster, getView, handle);
			return new sets.IsSet(aSet, bSet);
		}else if(rel.view === 'in'){
			var inputSet = makeRelSet(rel.params[0],  schema, fullSchema, objectState, variableMap, broadcaster, getView, handle);
			var filterSet = makeRelSet(rel.params[1], schema, fullSchema, objectState, variableMap, broadcaster, getView, handle);
			return new sets.InSet(inputSet, filterSet);
		}else{

			var viewSchema = fullSchema[rel.view];

			var paramValues = [];
			for(var i=0;i<rel.params.length;++i){
				var p = rel.params[i];
				var prs = makeRelSet(p, schema, fullSchema,  objectState, variableMap, broadcaster, getView, handle);
				paramValues.push(prs);
			}
			var paramsStr = JSON.stringify(paramValues);
			return new sets.ViewWrapperSet(paramsStr, viewSchema.code, getView(viewSchema.code, paramValues, paramsStr));
		}
	}else if(rel.type === 'macro'){
		var inputSet = makeRelSet(rel.context, schema, fullSchema, objectState, variableMap, broadcaster, getView, handle);
		return new sets.MacroSet(inputSet, rel.expr, variableMap, schema, fullSchema, objectState, broadcaster, handle, getView);
	}else if(rel.type === 'ampersand'){
		_.assertDefined(variableMap['&']);
		return variableMap['&'];
	}else if(rel.type === 'property'){
		var contextSet = makeRelSet(rel.context, schema, fullSchema, objectState, variableMap, broadcaster, getView, handle);
		return new sets.PropertySet(rel, contextSet, objectState);
	}else if(rel.type === 'value'){
		return new sets.PrimitiveSet(rel.value);
	}else{
		_.errout('unknown type: ' + rel.type + ' ' + JSON.stringify(rel));
	}
}

function processParams(schema, params, fullSchema, objectState, broadcaster, handle){
	_.assertLength(arguments, 6);

	var result = [];

	//console.log(schema.params);
	_.each(schema.params, function(p, index){
		if(p.type.type === 'primitive'){
			var v = params[index];
			console.log('made primitive set for value: ' + v);
			console.log('params: ' + params);
			result.push(new sets.PrimitiveSet(v));
		}else if(p.type.type === 'set'){
			var v = params[index];
			_.assertArray(v);
			result.push(new sets.StaticSet(v));
		}else if(p.type.type === 'object'){
			var id = params[index];
			var objectSchema = fullSchema[p.type.object];
			result.push(new sets.SingleObjectSet(objectSchema.code, id, objectState, broadcaster, vs));
		}else{
			_.errout('TODO handle param type: ' + JSON.stringify(p.type));
		}
	});
	
	return result;
}

exports.make = function(){

	var handle = {
		processParams: function(schema, params, fullSchema, objectState, broadcaster){
			_.assertLength(arguments, 5);
			return processParams(schema, params, fullSchema, objectState, broadcaster, handle);
		},
		makeSet: function(rel, schema, fullSchema, objectState, variableMap, broadcaster, getView){
			_.assertLength(arguments, 7);
			return makeRelSet(rel, schema, fullSchema, objectState, variableMap, broadcaster, getView, handle)
		},
		makePathSet: function(contextSchema, expr, schema, objects, broadcaster, variableMap){
			_.assertLength(arguments, 6);
			return makePathSet(contextSchema, expr, schema, objects, broadcaster, variableMap, handle);
		}
	};
	
	return handle;
}


